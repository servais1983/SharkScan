"""
Vulnerability signature system for SharkScan
"""

import json
import os
import re
from typing import Dict, List, Optional, Pattern, Set, Tuple, Any
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor
from functools import lru_cache
from .secure_logger import SecureLogger

class VulnerabilitySignatures:
    """Vulnerability signature detection system"""
    
    def __init__(self, signatures_dir: str = "data/signatures", max_workers: int = 4):
        """
        Initialize vulnerability signatures
        
        Args:
            signatures_dir (str): Directory containing signature files
            max_workers (int): Maximum number of worker threads
        """
        self.logger = SecureLogger("vuln_signatures")
        self.signatures_dir = signatures_dir
        self.max_workers = max_workers
        self.signatures = self._load_signatures()
        self.compiled_patterns = self._compile_patterns()
        self._setup_advanced_detection()
        self._setup_false_positive_management()
        self._setup_performance_optimizations()
        
    def _compile_patterns(self) -> Dict[str, Dict[str, List[Pattern]]]:
        """Compile regex patterns for vulnerability detection"""
        compiled = {}
        for category, vulns in self.signatures.items():
            compiled[category] = {}
            for vuln_id, signature in vulns.items():
                patterns = []
                if isinstance(signature.get('pattern'), list):
                    for pattern in signature['pattern']:
                        try:
                            patterns.append(re.compile(pattern, re.IGNORECASE | re.MULTILINE))
                        except re.error as e:
                            self.logger.error(f"Invalid pattern for {vuln_id}: {str(e)}")
                elif isinstance(signature.get('pattern'), str):
                    try:
                        patterns.append(re.compile(signature['pattern'], re.IGNORECASE | re.MULTILINE))
                    except re.error as e:
                        self.logger.error(f"Invalid pattern for {vuln_id}: {str(e)}")
                compiled[category][vuln_id] = patterns
        return compiled
        
    def _setup_performance_optimizations(self):
        """Setup performance optimizations"""
        # Initialize thread pool
        self.executor = ThreadPoolExecutor(max_workers=self.max_workers)
        
        # Setup caching
        self._cache_pattern_matches = lru_cache(maxsize=1000)(self._pattern_matches)
        self._cache_context_analysis = lru_cache(maxsize=100)(self._analyze_context)
        
        # Initialize pattern groups
        self.pattern_groups = self._group_patterns_by_category()
        
    def _group_patterns_by_category(self) -> Dict[str, List[Pattern]]:
        """Group patterns by category for faster matching"""
        groups = {}
        for category, vulns in self.compiled_patterns.items():
            groups[category] = []
            for patterns in vulns.values():
                groups[category].extend(patterns)
        return groups
        
    def _pattern_matches(self, pattern: Pattern, text: str) -> bool:
        """Check if pattern matches text (cached)"""
        return bool(pattern.search(text))
        
    def scan_response(self, response: str, category: str) -> Tuple[List[Dict], float]:
        """
        Scan response for vulnerabilities with optimized detection
        
        Args:
            response (str): Response to scan
            category (str): Category of signatures to use
            
        Returns:
            Tuple[List[Dict], float]: List of detected vulnerabilities and risk score
        """
        vulnerabilities = []
        
        try:
            if category not in self.signatures:
                self.logger.warning(f"Invalid category: {category}")
                return vulnerabilities, 0.0
                
            # Extract context
            context = self._extract_context(response, category)
            
            # Parallel pattern matching
            futures = []
            for vuln_id, signature in self.signatures[category].items():
                for pattern in self.compiled_patterns[category][vuln_id]:
                    futures.append(
                        self.executor.submit(
                            self._check_vulnerability,
                            pattern,
                            vuln_id,
                            signature,
                            response,
                            context
                        )
                    )
                    
            # Collect results
            for future in futures:
                result = future.result()
                if result:
                    vulnerabilities.append(result)
                    
            # Analyze context for additional vulnerabilities
            additional_vulns = self._cache_context_analysis(context, category)
            vulnerabilities.extend(additional_vulns)
            
            # Calculate risk score
            risk_score = self._calculate_risk_score(vulnerabilities)
            
            return vulnerabilities, risk_score
            
        except Exception as e:
            self.logger.error(f"Error scanning response: {str(e)}")
            return vulnerabilities, 0.0
            
    def _check_vulnerability(self, pattern: Pattern, vuln_id: str, signature: Dict,
                           response: str, context: Dict[str, Any]) -> Optional[Dict]:
        """Check for vulnerability with pattern"""
        if self._cache_pattern_matches(pattern, response):
            # Check for false positives
            if not self._is_false_positive(vuln_id, signature.get('category', 'unknown'), context):
                return {
                    'id': vuln_id,
                    'name': signature['name'],
                    'severity': signature['severity'],
                    'description': signature['description'],
                    'cwe': signature.get('cwe', 'N/A'),
                    'remediation': signature.get('remediation', 'N/A'),
                    'pattern': pattern.pattern,
                    'timestamp': datetime.now().isoformat(),
                    'context': context.get('headers', [])[:5],
                    'confidence': self._calculate_confidence(vuln_id, signature.get('category', 'unknown'), context)
                }
        return None
        
    def _setup_advanced_detection(self):
        """Setup advanced detection features"""
        self.context_patterns = {
            'web': {
                'headers': re.compile(r'^(?:[A-Za-z-]+):.*$', re.MULTILINE),
                'cookies': re.compile(r'Set-Cookie:.*?;', re.MULTILINE),
                'forms': re.compile(r'<form.*?</form>', re.DOTALL | re.IGNORECASE),
                'scripts': re.compile(r'<script.*?</script>', re.DOTALL | re.IGNORECASE)
            },
            'api': {
                'endpoints': re.compile(r'/[a-zA-Z0-9_/-]+'),
                'methods': re.compile(r'(GET|POST|PUT|DELETE|PATCH)'),
                'parameters': re.compile(r'[?&]([^=&]+)=([^&]*)')
            }
        }
        
        self.risk_factors = {
            'CRITICAL': 4,
            'HIGH': 3,
            'MEDIUM': 2,
            'LOW': 1
        }
        
    def _setup_false_positive_management(self):
        """Setup enhanced false positive management system"""
        self.false_positive_patterns = {
            'web': {
                'xss': [
                    r'<script>console\.log\(.*?\)</script>',  # Console logs
                    r'<script>window\.onload=.*?</script>',  # Window onload
                    r'<script>document\.addEventListener\(.*?\)</script>',  # Event listeners
                    r'<script>jQuery\(.*?\)</script>',  # jQuery initialization
                    r'<script>document\.ready\(.*?\)</script>'  # Document ready
                ],
                'sql_injection': [
                    r'SELECT.*?FROM.*?WHERE.*?=\s*\d+',  # Numeric queries
                    r'SELECT.*?FROM.*?WHERE.*?=\s*\'[a-zA-Z0-9]+\'',  # Simple string queries
                    r'SELECT.*?FROM.*?WHERE.*?=\s*"[a-zA-Z0-9]+"',  # Double quoted strings
                    r'SELECT.*?FROM.*?WHERE.*?IN\s*\([^)]+\)'  # IN clauses
                ],
                'path_traversal': [
                    r'\.\./\.\./assets/',  # Asset paths
                    r'\.\./\.\./images/',  # Image paths
                    r'\.\./\.\./css/',  # CSS paths
                    r'\.\./\.\./js/'  # JavaScript paths
                ]
            },
            'api': {
                'insecure_deserialization': [
                    r'JSON\.parse\(.*?\)',  # JSON parsing
                    r'Object\.fromEntries\(.*?\)',  # Object creation
                    r'Object\.assign\(.*?\)',  # Object assignment
                    r'Object\.create\(.*?\)'  # Object creation
                ],
                'jwt_vulnerabilities': [
                    r'eyJ[A-Za-z0-9-_=]+\.[A-Za-z0-9-_=]+\.?[A-Za-z0-9-_.+/=]*',  # JWT tokens
                    r'Bearer\s+eyJ[A-Za-z0-9-_=]+\.[A-Za-z0-9-_=]+\.?[A-Za-z0-9-_.+/=]*'  # Bearer tokens
                ]
            },
            'cloud': {
                'exposed_credentials': [
                    r'AWS_ACCESS_KEY_ID=AKIA[A-Z0-9]{16}',  # AWS access keys
                    r'GOOGLE_APPLICATION_CREDENTIALS=.*?\.json',  # Google credentials
                    r'AZURE_STORAGE_KEY=[A-Za-z0-9+/]{32,}={0,2}'  # Azure storage keys
                ],
                'insecure_storage': [
                    r'public-read',  # Public read access
                    r'public-write',  # Public write access
                    r'public-read-write'  # Public read-write access
                ]
            }
        }
        
        # Compile false positive patterns
        self.compiled_fp_patterns = {}
        for category, vulns in self.false_positive_patterns.items():
            self.compiled_fp_patterns[category] = {}
            for vuln_id, patterns in vulns.items():
                self.compiled_fp_patterns[category][vuln_id] = [
                    re.compile(pattern, re.IGNORECASE | re.MULTILINE)
                    for pattern in patterns
                ]
                
    def _is_false_positive(self, vuln_id: str, category: str, context: Dict[str, Any]) -> bool:
        """
        Enhanced false positive detection
        
        Args:
            vuln_id (str): Vulnerability ID
            category (str): Category of vulnerability
            context (Dict[str, Any]): Context information
            
        Returns:
            bool: True if false positive
        """
        if category not in self.compiled_fp_patterns or vuln_id not in self.compiled_fp_patterns[category]:
            return False
            
        # Check response body
        if 'body' in context:
            for pattern in self.compiled_fp_patterns[category][vuln_id]:
                if pattern.search(context['body']):
                    return True
                    
        # Check headers
        if 'headers' in context:
            headers_str = '\n'.join(context['headers'])
            for pattern in self.compiled_fp_patterns[category][vuln_id]:
                if pattern.search(headers_str):
                    return True
                    
        # Check cookies
        if 'cookies' in context:
            cookies_str = '\n'.join(context['cookies'])
            for pattern in self.compiled_fp_patterns[category][vuln_id]:
                if pattern.search(cookies_str):
                    return True
                    
        # Check forms
        if 'forms' in context:
            forms_str = '\n'.join(context['forms'])
            for pattern in self.compiled_fp_patterns[category][vuln_id]:
                if pattern.search(forms_str):
                    return True
                    
        return False
        
    def _calculate_confidence(self, vuln_id: str, category: str, context: Dict[str, Any]) -> float:
        """
        Calculate enhanced confidence score
        
        Args:
            vuln_id (str): Vulnerability ID
            category (str): Category of vulnerability
            context (Dict[str, Any]): Context information
            
        Returns:
            float: Confidence score (0-1)
        """
        confidence = 0.5  # Base confidence
        
        # Adjust based on context
        if 'headers' in context:
            confidence += 0.1
            
        if 'body' in context:
            confidence += 0.1
            
        if 'cookies' in context:
            confidence += 0.1
            
        # Adjust based on category-specific factors
        if category == 'web':
            if 'forms' in context:
                confidence += 0.1
            if 'scripts' in context:
                confidence += 0.1
                
        elif category == 'api':
            if 'endpoints' in context:
                confidence += 0.1
            if 'methods' in context:
                confidence += 0.1
                
        # Adjust based on false positive patterns
        if self._is_false_positive(vuln_id, category, context):
            confidence -= 0.3
            
        return max(0.0, min(confidence, 1.0))  # Ensure between 0 and 1
        
    def _extract_context(self, response: str, category: str) -> Dict[str, List[str]]:
        """
        Extract context-specific information from response
        
        Args:
            response (str): Response to analyze
            category (str): Category of analysis
            
        Returns:
            Dict[str, List[str]]: Extracted context information
        """
        context = {}
        
        if category in self.context_patterns:
            for context_type, pattern in self.context_patterns[category].items():
                matches = pattern.findall(response)
                if matches:
                    context[context_type] = matches
                    
        return context
        
    def _calculate_risk_score(self, vulnerabilities: List[Dict]) -> float:
        """
        Calculate overall risk score for detected vulnerabilities
        
        Args:
            vulnerabilities (List[Dict]): List of detected vulnerabilities
            
        Returns:
            float: Risk score (0-10)
        """
        if not vulnerabilities:
            return 0.0
            
        total_score = sum(self.risk_factors.get(v['severity'], 0) for v in vulnerabilities)
        max_possible = len(vulnerabilities) * max(self.risk_factors.values())
        
        return (total_score / max_possible) * 10
        
    def _analyze_context(self, context: Dict[str, List[str]], category: str) -> List[Dict]:
        """
        Analyze context for additional vulnerabilities
        
        Args:
            context (Dict[str, List[str]]): Context information
            category (str): Category of analysis
            
        Returns:
            List[Dict]: Additional vulnerabilities found
        """
        additional_vulns = []
        
        if category == 'web':
            # Check for security headers
            if 'headers' in context:
                security_headers = {
                    'X-Frame-Options': 'Missing X-Frame-Options header',
                    'X-Content-Type-Options': 'Missing X-Content-Type-Options header',
                    'Content-Security-Policy': 'Missing Content-Security-Policy header',
                    'Strict-Transport-Security': 'Missing HSTS header'
                }
                
                headers = [h.split(':')[0] for h in context['headers']]
                for header, message in security_headers.items():
                    if header not in headers:
                        additional_vulns.append({
                            'id': f'missing_{header.lower()}',
                            'name': f'Missing Security Header: {header}',
                            'severity': 'MEDIUM',
                            'description': message,
                            'cwe': 'CWE-1021',
                            'remediation': f'Add {header} header with appropriate value'
                        })
                        
            # Check for secure cookie flags
            if 'cookies' in context:
                for cookie in context['cookies']:
                    if 'secure' not in cookie.lower() and 'httponly' not in cookie.lower():
                        additional_vulns.append({
                            'id': 'insecure_cookie',
                            'name': 'Insecure Cookie Configuration',
                            'severity': 'HIGH',
                            'description': 'Cookie missing secure and HttpOnly flags',
                            'cwe': 'CWE-614',
                            'remediation': 'Add secure and HttpOnly flags to cookies'
                        })
                        
        elif category == 'api':
            # Check for rate limiting
            if 'headers' in context:
                if not any('rate-limit' in h.lower() for h in context['headers']):
                    additional_vulns.append({
                        'id': 'missing_rate_limit',
                        'name': 'Missing Rate Limiting',
                        'severity': 'MEDIUM',
                        'description': 'API endpoint missing rate limiting',
                        'cwe': 'CWE-770',
                        'remediation': 'Implement rate limiting for API endpoints'
                    })
                    
            # Check for versioning
            if 'endpoints' in context:
                if not any('/v' in endpoint for endpoint in context['endpoints']):
                    additional_vulns.append({
                        'id': 'missing_versioning',
                        'name': 'Missing API Versioning',
                        'severity': 'LOW',
                        'description': 'API endpoints missing versioning',
                        'cwe': 'CWE-1104',
                        'remediation': 'Implement API versioning'
                    })
                    
        return additional_vulns
        
    def get_vulnerability_stats(self, vulnerabilities: List[Dict]) -> Dict:
        """
        Get statistics about detected vulnerabilities
        
        Args:
            vulnerabilities (List[Dict]): List of detected vulnerabilities
            
        Returns:
            Dict: Vulnerability statistics
        """
        stats = {
            'total': len(vulnerabilities),
            'by_severity': {},
            'by_category': {},
            'unique_cwe': set()
        }
        
        for vuln in vulnerabilities:
            # Count by severity
            severity = vuln['severity']
            stats['by_severity'][severity] = stats['by_severity'].get(severity, 0) + 1
            
            # Count by category
            category = vuln.get('category', 'unknown')
            stats['by_category'][category] = stats['by_category'].get(category, 0) + 1
            
            # Track unique CWE IDs
            if 'cwe' in vuln and vuln['cwe'] != 'N/A':
                stats['unique_cwe'].add(vuln['cwe'])
                
        # Convert CWE set to count
        stats['unique_cwe'] = len(stats['unique_cwe'])
        
        return stats
            
    def _load_signatures(self) -> Dict:
        """Load vulnerability signatures from files"""
        signatures = {
            'web': {},
            'network': {},
            'service': {},
            'api': {},
            'cloud': {}
        }
        
        try:
            # Create signatures directory if it doesn't exist
            os.makedirs(self.signatures_dir, exist_ok=True)
            
            # Load signatures for each category
            for category in signatures.keys():
                sig_file = os.path.join(self.signatures_dir, f"{category}_signatures.json")
                if os.path.exists(sig_file):
                    with open(sig_file, 'r') as f:
                        signatures[category] = json.load(f)
                else:
                    # Create default signatures file
                    self._create_default_signatures(category)
                    
            return signatures
            
        except Exception as e:
            self.logger.error(f"Error loading signatures: {str(e)}")
            return signatures
            
    def _create_default_signatures(self, category: str) -> None:
        """Create default signatures file for a category"""
        default_signatures = {
            'web': {
                'xss': {
                    'name': 'Cross-Site Scripting',
                    'patterns': [
                        r'<script>.*?</script>',
                        r'javascript:.*?\(.*?\)',
                        r'on\w+=.*?\(.*?\)',
                        r'data:text/html.*?<script>',
                        r'vbscript:.*?\(.*?\)'
                    ],
                    'severity': 'HIGH',
                    'description': 'Cross-Site Scripting vulnerability',
                    'cwe': 'CWE-79',
                    'remediation': 'Implement proper input validation and output encoding'
                },
                'sql_injection': {
                    'name': 'SQL Injection',
                    'patterns': [
                        r"'.*?OR.*?'1'='1",
                        r"'.*?UNION.*?SELECT",
                        r"'.*?DROP.*?TABLE",
                        r"'.*?EXEC.*?xp_",
                        r"'.*?WAITFOR.*?DELAY"
                    ],
                    'severity': 'CRITICAL',
                    'description': 'SQL Injection vulnerability',
                    'cwe': 'CWE-89',
                    'remediation': 'Use parameterized queries and input validation'
                },
                'path_traversal': {
                    'name': 'Path Traversal',
                    'patterns': [
                        r'\.\./\.\./',
                        r'\.\.\\\.\.\\',
                        r'%2e%2e%2f',
                        r'%252e%252e%252f'
                    ],
                    'severity': 'HIGH',
                    'description': 'Path traversal vulnerability',
                    'cwe': 'CWE-22',
                    'remediation': 'Implement proper path validation and sanitization'
                },
                'open_redirect': {
                    'name': 'Open Redirect',
                    'patterns': [
                        r'redirect=.*?http[s]?://',
                        r'url=.*?http[s]?://',
                        r'return=.*?http[s]?://',
                        r'next=.*?http[s]?://',
                        r'dest=.*?http[s]?://'
                    ],
                    'severity': 'HIGH',
                    'description': 'Open redirect vulnerability',
                    'cwe': 'CWE-601',
                    'remediation': 'Validate and sanitize redirect URLs'
                },
                'ssrf': {
                    'name': 'Server-Side Request Forgery',
                    'patterns': [
                        r'http[s]?://(?:localhost|127\.0\.0\.1|0\.0\.0\.0)',
                        r'http[s]?://(?:10\.|172\.(?:1[6-9]|2[0-9]|3[0-1])\.|192\.168\.)',
                        r'file:///',
                        r'gopher://',
                        r'ldap://'
                    ],
                    'severity': 'HIGH',
                    'description': 'SSRF vulnerability',
                    'cwe': 'CWE-918',
                    'remediation': 'Implement URL validation and whitelisting'
                }
            },
            'network': {
                'weak_ciphers': {
                    'name': 'Weak SSL/TLS Ciphers',
                    'patterns': [
                        r'RC4',
                        r'DES',
                        r'3DES',
                        r'MD5',
                        r'NULL',
                        r'EXPORT',
                        r'LOW'
                    ],
                    'severity': 'MEDIUM',
                    'description': 'Weak encryption ciphers detected',
                    'cwe': 'CWE-326',
                    'remediation': 'Disable weak ciphers and use strong encryption'
                },
                'default_credentials': {
                    'name': 'Default Credentials',
                    'patterns': [
                        r'admin:admin',
                        r'root:root',
                        r'guest:guest',
                        r'administrator:password',
                        r'cisco:cisco'
                    ],
                    'severity': 'HIGH',
                    'description': 'Default credentials in use',
                    'cwe': 'CWE-521',
                    'remediation': 'Change default credentials immediately'
                },
                'insecure_protocols': {
                    'name': 'Insecure Protocols',
                    'patterns': [
                        r'FTP',
                        r'TELNET',
                        r'SNMPv1',
                        r'HTTP/1.0'
                    ],
                    'severity': 'MEDIUM',
                    'description': 'Insecure protocols in use',
                    'cwe': 'CWE-319',
                    'remediation': 'Use secure protocols (SFTP, SSH, SNMPv3, HTTPS)'
                }
            },
            'service': {
                'buffer_overflow': {
                    'name': 'Buffer Overflow',
                    'patterns': [
                        r'A{1000,}',
                        r'\\x90{100,}',
                        r'\\x41{500,}'
                    ],
                    'severity': 'CRITICAL',
                    'description': 'Potential buffer overflow vulnerability',
                    'cwe': 'CWE-120',
                    'remediation': 'Implement proper bounds checking and input validation'
                },
                'command_injection': {
                    'name': 'Command Injection',
                    'patterns': [
                        r'[;&|]',
                        r'`.*?`',
                        r'\$\(.*?\)',
                        r'exec\(.*?\)',
                        r'system\(.*?\)'
                    ],
                    'severity': 'HIGH',
                    'description': 'Command injection vulnerability',
                    'cwe': 'CWE-78',
                    'remediation': 'Use safe APIs and input validation'
                },
                'format_string': {
                    'name': 'Format String Vulnerability',
                    'patterns': [
                        r'%[0-9]*[sx]',
                        r'%[0-9]*[diu]',
                        r'%[0-9]*[fF]'
                    ],
                    'severity': 'HIGH',
                    'description': 'Format string vulnerability',
                    'cwe': 'CWE-134',
                    'remediation': 'Use proper format string functions'
                }
            },
            'api': {
                'insecure_deserialization': {
                    'name': 'Insecure Deserialization',
                    'patterns': [
                        r'ObjectInputStream',
                        r'XMLDecoder',
                        r'YAML.load',
                        r'pickle.loads'
                    ],
                    'severity': 'HIGH',
                    'description': 'Insecure deserialization vulnerability',
                    'cwe': 'CWE-502',
                    'remediation': 'Use safe deserialization methods and validate input'
                },
                'mass_assignment': {
                    'name': 'Mass Assignment',
                    'patterns': [
                        r'Object.assign',
                        r'Object.create',
                        r'Object.defineProperties'
                    ],
                    'severity': 'MEDIUM',
                    'description': 'Mass assignment vulnerability',
                    'cwe': 'CWE-915',
                    'remediation': 'Implement proper object property filtering'
                },
                'jwt_vulnerabilities': {
                    'name': 'JWT Vulnerabilities',
                    'patterns': [
                        r'eyJ[A-Za-z0-9-_=]+\.[A-Za-z0-9-_=]+\.?[A-Za-z0-9-_.+/=]*',
                        r'alg:\s*["\']none["\']',
                        r'alg:\s*["\']HS256["\']'
                    ],
                    'severity': 'HIGH',
                    'description': 'JWT implementation vulnerabilities',
                    'cwe': 'CWE-347',
                    'remediation': 'Use secure JWT implementation and validation'
                },
                'graphql_vulnerabilities': {
                    'name': 'GraphQL Vulnerabilities',
                    'patterns': [
                        r'__schema',
                        r'__type',
                        r'introspection',
                        r'fragment\s+on\s+\w+\s*{'
                    ],
                    'severity': 'MEDIUM',
                    'description': 'GraphQL introspection enabled',
                    'cwe': 'CWE-200',
                    'remediation': 'Disable introspection in production'
                }
            },
            'cloud': {
                'exposed_credentials': {
                    'name': 'Exposed Cloud Credentials',
                    'patterns': [
                        r'AWS_ACCESS_KEY_ID',
                        r'AWS_SECRET_ACCESS_KEY',
                        r'GOOGLE_APPLICATION_CREDENTIALS',
                        r'AZURE_STORAGE_KEY'
                    ],
                    'severity': 'CRITICAL',
                    'description': 'Exposed cloud service credentials',
                    'cwe': 'CWE-798',
                    'remediation': 'Remove exposed credentials and rotate keys'
                },
                'insecure_storage': {
                    'name': 'Insecure Cloud Storage',
                    'patterns': [
                        r'public-read',
                        r'public-write',
                        r'public-read-write'
                    ],
                    'severity': 'HIGH',
                    'description': 'Insecure cloud storage configuration',
                    'cwe': 'CWE-284',
                    'remediation': 'Implement proper access controls'
                },
                'exposed_cloud_metadata': {
                    'name': 'Exposed Cloud Metadata',
                    'patterns': [
                        r'http://169\.254\.169\.254/',
                        r'http://metadata\.google\.internal/',
                        r'http://169\.254\.170\.2/',
                        r'http://localhost:1338/'
                    ],
                    'severity': 'HIGH',
                    'description': 'Exposed cloud metadata service',
                    'cwe': 'CWE-200',
                    'remediation': 'Restrict access to metadata services'
                },
                'insecure_cloud_storage': {
                    'name': 'Insecure Cloud Storage',
                    'patterns': [
                        r'public-read',
                        r'public-write',
                        r'public-read-write',
                        r'Allow: \*'
                    ],
                    'severity': 'HIGH',
                    'description': 'Insecure cloud storage configuration',
                    'cwe': 'CWE-284',
                    'remediation': 'Implement proper access controls'
                }
            }
        }
        
        try:
            sig_file = os.path.join(self.signatures_dir, f"{category}_signatures.json")
            with open(sig_file, 'w') as f:
                json.dump(default_signatures[category], f, indent=2)
                
        except Exception as e:
            self.logger.error(f"Error creating default signatures: {str(e)}")
            
    def add_signature(self, category: str, vuln_id: str, signature: Dict) -> bool:
        """
        Add new vulnerability signature
        
        Args:
            category (str): Category of signature
            vuln_id (str): Vulnerability ID
            signature (Dict): Signature details
            
        Returns:
            bool: True if successful
        """
        try:
            if category not in self.signatures:
                self.signatures[category] = {}
                
            self.signatures[category][vuln_id] = signature
            
            # Save to file
            sig_file = os.path.join(self.signatures_dir, f"{category}_signatures.json")
            with open(sig_file, 'w') as f:
                json.dump(self.signatures[category], f, indent=2)
                
            self.logger.info(f"Added signature: {vuln_id} to {category}")
            return True
            
        except Exception as e:
            self.logger.error(f"Error adding signature: {str(e)}")
            return False
            
    def get_signatures(self, category: Optional[str] = None) -> Dict:
        """
        Get vulnerability signatures
        
        Args:
            category (str, optional): Category to get signatures for
            
        Returns:
            Dict: Vulnerability signatures
        """
        if category:
            return self.signatures.get(category, {})
        return self.signatures 